#!/usr/bin/env python

import os
import sys

def _neeed(lib):
	print >> sys.stderr, "ERROR: You need to install the gitpython python library to use this tool"
	sys.exit(1)
try:
	import git
except ImportError:
	_need('gitpython')
try:
	import termstyle as col
except ImportError:
	_need('termstyle')

def main(files=None):
	if files is None:
		files = sys.argv[1:]
	if len(files) == 0:
		files = os.listdir('.')
		files = [fl for fl in files if os.path.isdir(fl)]

	for file_ in files:
		repo = get_repo(file_)
		if repo is None:
			continue
		print fmt_repo(repo, file_)
	
def get_repo(path):
	try:
		return git.Repo(path)
	except git.InvalidGitRepositoryError:
		return None

def fmt_repo(repo, path):
	if repo is None:
		return col.black("[n/a: ",path,"]")
	parts = []
	path_col = col.red if repo.is_dirty else col.yellow

	active_branch = repo.active_branch
	branch_str = col.cyan(":", active_branch) if active_branch != 'master' else ''
	parts.append(path_col(path))
	parts.append(branch_str)
	parts.append(format_remote_info(repo, active_branch))

	return ''.join(parts)

def format_remote_info(repo, branch):
	remote_infos = remote_info(repo)
	# sort by "least divergent first"
	parts = []
	remote_infos = sorted(remote_infos, key=lambda x: x[1])
	for remote_url, advanced in remote_infos:
		if remote_url.endswith("/" + branch):
			remote_url = remote_url.rsplit('/', 1)[0]
		if advanced == 0:
			parts.append(col.green(" = ", remote_url))
		else:
			sign = "+" if advanced > 0 else ""
			parts.append(", %s:%s" % (col.red(sign, advanced), remote_url))
	return ''.join(parts)
	

def remote_info(repo):
	"""return a list of (remote_url, commits_ahead) pairs for each remote in repo"""
	# basic operation is:
	# git-for-each-ref refs/remotes -> to get a list of remote refs
	# git-rev-list <remote_url>..HEAD -> to find all the commits ahead of remote URL
	def get_remote_urls(repo):
		remote_str = 'refs/remotes'
		lines = repo.git.for_each_ref(remote_str).splitlines()
		return [line.split(remote_str)[1][1:] for line in lines if not line.endswith('HEAD')]

	def commits_ahead_of(repo, remote_url):
		def diff(start, finish):
			commits = repo.git.rev_list("%s..%s" % (start,finish)).splitlines()
			return len(commits)
			
		commits = diff(remote_url, "HEAD")
		if commits > 0:
			return commits
		back_commits = diff("HEAD", remote_url)
		return -back_commits
		
	
	return [(url, commits_ahead_of(repo, url)) for url in get_remote_urls(repo)]

if __name__ == '__main__':
	sys.exit(main())

