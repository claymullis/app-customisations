set nocompatible
" pathogen bootstrap, then use it to make $VIMPATH useful
let &runtimepath = $PATHOGEN_ROOT . "," . &runtimepath
let &runtimepath = pathogen#join(split($VIMPATH,':'),&runtimepath)
call pathogen#runtime_append_all_bundles()

" reload filetype detection
filetype off
filetype plugin indent on

syntax on
syntax sync minlines=200 " don't lose track of syntax highlighting when in large syntax blocks
set number
let g:solarized_contrast="high"
set background="dark"
" sorry solarized, but you're rubbish at terminal mode...
if has("gui_running")
	set guifont=Monospace\ 11
	color solarized
else
	color ir_black
end

set encoding=utf-8
set textwidth=0
set noswapfile
set nobackup
set nojoinspaces " just one space after a period (when joining)
set nofoldenable " I can never remember how to use folding
set autoread " reload file whenever it changes on disk
set autowrite " save file when navigating away from it or using :make (but not on quits, etc)
set wrapmargin=5
set nowrap
set formatoptions=crqln
set backspace=indent,eol,start
set guitablabel=%N\ %t\ %m%r
set guioptions-=T "remove toolbar
set diffopt+=vertical
set shiftround " round to multiples of shiftwidth for > and <
set wildignore=*.swp,*.bak,*.pyc,*.class
set pastetoggle=<F2>
set sessionoptions="curdir,folds,localoptions,tabpages,winsize"
autocmd SessionLoadPost * tab ball
set sessionoptions=blank,buffers,curdir,folds,resize,tabpages,winsize
command! -narg=0 SSession :mksession! .vimsession
command! -narg=0 LSession :source .vimsession
" let g:semantic_tabs="auto"

fun! FnEmailMode()
	setlocal spell mousemodel=popup
	setlocal wrap linebreak wrapmargin=0
	match none
endfun

fun! Wrap()
	setlocal textwidth=76
	setlocal formatoptions+=at
	match ErrorMsg '\%>78v.\+'
endfun
command! Wrap call Wrap()

fun! NoWrap()
	setlocal textwidth=0
	setlocal formatoptions-=at
	match none
endfun
command! NoWrap call NoWrap()

" default to email mode when we were spawned by the edit server
if $FROM_EDIT_SERVER == 'true'
	call FnEmailMode()
end

command! Emailmode call FnEmailMode()

command! -nargs=0 Spaces set et noet< | retab
fun! Tabsize(sz)
	let &l:shiftwidth=a:sz
	let &l:tabstop=a:sz
	let &l:softtabstop=a:sz
endfun
fun! GlobalTabsize(sz)
	let &shiftwidth=a:sz
	let &tabstop=a:sz
	let &softtabstop=a:sz
endfun
command! -nargs=1 Tabsize call Tabsize(<args>)

call GlobalTabsize(2)
set cursorline
set ignorecase
set smartcase
set incsearch
set scrolloff=3
set sidescrolloff=5
set wildmode=longest,list
set autoindent
set cinkeys-=#
set mouse=a
" allow status-bar windows (0-height)
set wmh=0
" set iskeyword-=_ \" allow underscore to delimit words"

set tags+=.tags
let g:autotagTagsFile=".tags"
let g:EasyMotion_leader_key = '<Leader>m'
let g:EasyMotion_mapping_f = '<leader>f'
let g:EasyMotion_mapping_F = '<leader>F'
let g:EasyMotion_mapping_w = '<leader>w'
let g:EasyMotion_mapping_W = '<leader>W'
let g:EasyMotion_mapping_j = '<leader>j'
let g:EasyMotion_mapping_k = '<leader>k'
omap <silent> i_ <Plug>CamelCaseMotion_iw
xmap <silent> i_ <Plug>CamelCaseMotion_iw
omap <silent> i- <Plug>CamelCaseMotion_iw
xmap <silent> i- <Plug>CamelCaseMotion_iw
map <silent> _ <Plug>CamelCaseMotion_w
map <silent> <a--> <Plug>CamelCaseMotion_b

" (do it poorly in the terminal, because sometimes utf8 is broken)
fun! Lame_tabs()
	autocmd BufNewFile,BufRead * set list listchars=tab:>\ 
	set list listchars=tab:>\ 
endfun
command! LameTabs call Lame_tabs()

" draw tabs
autocmd BufNewFile,BufRead * set list listchars=tab:▸\ 
set list listchars=tab:▸\ 

"highlight any spaces that are followed by a tab (the horror!)
" and any _single_ space that comes after ^\t+ (this is usually accedental)
" and also trailing spaces
autocmd BufNewFile,BufRead * match Error /\(  \+\t\@=\)\|\(^\(\t\+\)\zs \ze[^ *]\)\|\([^ \t]\zs\s\+$\)/
                             match Error /\(  \+\t\@=\)\|\(^\(\t\+\)\zs \ze[^ *]\)\|\([^ \t]\zs\s\+$\)/


fun! Save_if_possible()
	if len(expand("%")) > 0 && &buftype == ""
		:up
	else
		echo "[no file]"
	endif
endfun
autocmd FocusLost * call Save_if_possible()

augroup mkd
	autocmd BufRead *.mkd  set ai formatoptions=tcroqn2 comments=n:&gt spell mousemodel=popup textwidth=70;
augroup END


"" tab left & right
map <A-j> gt
map <A-k> gT
" same for macvim (cmd key, because alt doesn't work)
""NOTE: only run this on macvim - on gnome, it causes an ambiguous map for "<<" (unindent line)
"map <D-j> gt
"map <D-k> gT

" Visually select the text that was last edited/pasted
nmap gV `[V`]

" Bubble single lines
nmap <M-Down> ]e
nmap <M-S-J> ]e
nmap <M-Up> [e
nmap <M-S-K> [e
" Bubble selection
vmap <M-Down> ]e`[V`]
vmap <M-S-J> ]e`[V`]
vmap <M-Up> [e`[V`]
vmap <M-S-K> [e`[V`]

" use , for ;
nnoremap , ;
vnoremap , ;
nnoremap ; :
" visual mappings to highlight inside brackets ((like this) and this)
vmap ] i]
vmap [ i[
vmap ) i)
vmap ( i(
vmap ; ib
nmap c] ci]
nmap c[ ci[
nmap c) ci)
nmap c( ci(
nmap c{ ci{
nmap c} ci}
nmap c; cib
" and keep going ...
" ctrl + b to highlight current word
map <Leader>b viw
" and then keep extending it
vmap <Leader>b o?\<<cr>o2/\><cr>h
" \w should maybe do the same thing?
nmap <leader>w <c-b>
vmap <leader>w <c-b>

xmap <Leader>s <Plug>Vsurround
" surround selection with things:
vmap <leader>( <esc>`>a)<esc>`<i(<esc>
vmap <leader>[ <esc>`>a]<esc>`<i[<esc>
"vmap <leader>< <esc>`>a><esc>`<i<<esc>
vmap <leader>{ <esc>`>a}<esc>`<i{<esc>
vmap <leader>' <esc>`>a'<esc>`<i'<esc>
vmap <leader>" <esc>`>a"<esc>`<i"<esc>
vmap <leader>` <esc>`>a`<esc>`<i`<esc>
nmap <leader>' vi'
nmap <leader>" vi"
nmap <leader>[ vi[
nmap <leader>` vi`

" ]] to go to next (/prev) quickfix item
nmap <A-]> :cn<cr>
nmap <A-[> :cp<cr>

" + expands a selection in both directions by one character
vmap + loho
vmap - holo

" + to increment a number (used to be c-a, but it hardly deserves such a prominent shortcut)
nnoremap + <c-a>

" ) kills the surrounding characters of a selection
vmap <leader>) <esc>`<hx`>x

" home & end
map <C-l> $
map <C-h> ^
" nul is ctrl-space for terminal
map <nul> ^
map <space> h
map <C-Space> ^
map <S-Space> b
" foward & back words at a time
map <S-h> b
map <S-l> w

" ctrl + backspace for deleting a word
imap <C-BS> <C-W>

" ctrl + space to insert an underscore
imap <C-space> _

" scroll (without moving cursor) on ctrl+j/k
map <C-k> <C-y>
map <C-j> <C-e>

" I want { and } to match whitespace-only lines, rather than just empty ones
" TODO: need to omit these from the search history
noremap { :silent ?^\s*$<cr>:silent nohl<cr>
noremap } :silent /^\s*$<cr>:silent nohl<cr>

vnoremap { ?^\s*$<cr>
vnoremap } /^\s*$<cr>

" copy / paste (gvim, with the gui clipboard)
vmap <C-c> "+y
inoremap <C-v> <C-r>+
cnoremap <C-v> <C-r>+
" c-v is still sometimes useful for literal <cr> chars, so use <c-l> (mnemonic 'literal')
cnoremap <C-l> <C-v>
inoremap <C-l> <C-v>

" shift-insert for pasting from the selection buffer
nmap <S-Ins> "*P
imap <S-Ins> <esc>"*pa
omap <S-Ins> <C-r>*
cmap <S-Ins> <c-r>*

" select all in visual mode
vmap <C-a> <esc>ggVG
nmap <C-a> ggVG

" delete to the "black hole" buffer
map <S-k> "_d

" new tab with <leader>T
nmap <leader>T :tabnew<cr>

" map alt+slash to line comment toggle
map <A-/> :TComment<cr>
"map <D-/> :TComment<cr>

" option (or alt) + r to run the current file
"nmap <D-r> :up<cr>:!%:p<cr>
nmap <A-r> :up<cr>:!%:p<cr>

" ctrl+s to save things!
nmap <C-s> :w<cr>
imap <C-s> <esc>:w<cr>a

" Q to (re) format things
vmap Q Jgqq
" Q to (re) format things
nmap Q gqq

nmap <leader>p V{jo}ko

let g:ctrlp_map=''
let g:ctrlp_working_path_mode=2 " current directory
let g:ctrlp_user_command = ['.git/', 'cd %s && git ls-files']
let g:ctrlp_by_filename = 1
let g:ctrlp_switch_buffer = 2

" CommandT requires compilation, so we use CtrlP as a more portable fallback
if exists(":CommandT")
	nmap <C-f> :CommandT<cr>
else
	nmap <C-f> :CtrlP<cr>
endif
" but always have ctrlp available as well
nmap <leader><C-f> :CtrlP<cr>
nmap <C-b> :CtrlPBuffer<cr>
" nmap <leader>b :FuzzyFinderBuffer<cr>
" nmap <leader>F :FuzzyFinderTaggedFile<cr>
nmap <leader>t :CtrlPTag<cr>

" leader-t for showing nerd-tree
nmap <leader>e :NERDTreeToggle<cr>
nmap <leader>E :NERDTreeFind<cr>

" find usages
nmap <a-F7> :Ack -wQ <c-r><c-w><cr>
vmap <M-F7> y:Ack -wQ "<C-R>""<cr>

" refresh / redraw
nmap <F5> :syntax sync fromstart<cr>:redraw!<cr>

" window management:
nmap <C-tab> <c-w>w
nmap <S-C-tab> <c-w>W
nmap <leader><c-l> <c-w>T

" copy full path to clipboard
nmap <C-c> :silent let @+ = expand("%:p")<cr>

nmap <A-o> :up<cr>:silent !gnome-open %:p<cr>
command! -narg=0 Open :silent :!gnome-open "`dirname "%:p"`" &
command! -narg=0 Term :silent :!gnome-terminal --working-directory="`dirname "%:p"`" &
command! -narg=0 CD :lcd %:p:h
command! -narg=0 Mdview :silent :!markdown "%" | htmlview &
command! -narg=0 Rstview :silent :!rst2html "%" | htmlview
augroup automake
augroup END
command! -narg=0 Automake autocmd automake BufWritePost <buffer> Make
command! -narg=0 AutomakeOff autocmd! automake

" silly shift-typos
command! -narg=0 Q :q
command! -narg=0 W :w
command! -narg=0 Wq :wq
command! -narg=0 WQ :wq

command! -narg=0 Xmlformat :%!XMLLINT_INDENT='	' xmllint --format -o - -
command! -narg=0 ClearMarkers :sign unplace *

" pyflakes shouldn't use quickfix; I use that for other stuff!
let g:pyflakes_use_quickfix = 0

" 0install tools helpers
command! -narg=0 Zeroreadme !cd %:p:h && 0readme %:t
command! -narg=0 Zerocopy !cd %:p:h && gnome-terminal -x /bin/bash -c "echo %:p; mkzero-gfxmonk -c %:t; bash"
command! -narg=0 Zerosign !cd %:p:h && gnome-terminal -x `which 0publish` --xmlsign %:p
command! Version !version

command! -narg=1 Boom put =system(\"boom echo <args>\")

if has("win32unix")
	" make `gf` work on windows paths
	set isfname+=:
	set isfname+=\\
	set includeexpr=substitute(system('cygpath\ '.shellescape(v:fname)),'\\n$','','')
end

