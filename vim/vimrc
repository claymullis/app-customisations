set nocompatible
let g:pathsep = ':'
if has("win32")
	let g:pathsep = ';'
	if exists("$PWD")
		" at least start in the right directory when launched from mingw / cygwin
		cd $PWD
	endif
endif

if has("mac")
	set macmeta
	" XXX am I using macvim wrong?
	if exists("$MACVIM_PWD")
		cd $MACVIM_PWD
	endif
endif

if stridx(&shell, "fish") != -1
	" vim and fish: worst of friends
	set shell=sh
endif

" pathogen bootstrap, then use it to make $VIMPATH useful
let &runtimepath = $PATHOGEN_ROOT . "," . &runtimepath
let &runtimepath = pathogen#join(split($VIMPATH,g:pathsep),&runtimepath)
call pathogen#runtime_append_all_bundles()

" reload filetype detection
filetype off
filetype plugin indent on

syntax on
syntax sync minlines=200 " don't lose track of syntax highlighting when in large syntax blocks
set number
let g:solarized_contrast="normal"
let g:solarized_italic=0
set background="dark"
" sorry solarized, but you're rubbish at terminal mode...
if has("gui_running")
	color solarized
	if has("win32")
		set guifont=Consolas:h12:cANSI
	elseif has("mac")
		set guifont=Menlo\ Regular:h16
	else
		set guifont=Monospace\ 11
	endif
else
	color ir_black
end

set encoding=utf-8
set textwidth=0
set copyindent
" insert a tab at the start of the line, without messing up existing (mixed) indents
nmap <leader><tab> m'0i<tab><esc>`'l
set noswapfile
set nobackup
set nojoinspaces " just one space after a period (when joining)
" set nofoldenable " I can never remember how to use folding
set autoread " reload file whenever it changes on disk
set autowrite " save file when navigating away from it or using :make (but not on quits, etc)
set wrapmargin=0
set nowrap
set formatoptions=crqln
set backspace=indent,eol,start
set guitablabel=%N\ %t\ %m%r
set guioptions-=T "remove toolbar
set guioptions-=m "remove menu bar
set diffopt+=vertical
set shiftround " round to multiples of shiftwidth for > and <
set wildignore+=*.swp,*.bak,*.pyc,*.class,*.cache
let g:CommandTWildIgnore=&wildignore . ",**/node_modules/*,**/tmp/*,**/_build*/**,**/0inst/**,**/*.0compile/**"
let g:ctrlp_custom_ignore = {
	\ 'dir': 'node_modules,tmp,_build,0inst,*.0compile',
	\ }
let g:rust_recommended_style=0 " quit it with your expandtab business

set pastetoggle=<F2>
set sessionoptions="curdir,folds,localoptions,tabpages,winsize"
autocmd SessionLoadPost * tab ball
set sessionoptions=blank,buffers,curdir,folds,resize,tabpages,winsize
command! -narg=0 SSession :mksession! .vimsession
command! -narg=0 LSession :source .vimsession

fun! FnEmailMode()
	setlocal spell mousemodel=popup
	setlocal wrap linebreak wrapmargin=0
	match none
endfun

fun! Wrap()
	setlocal textwidth=76
	setlocal formatoptions+=at
	match ErrorMsg '\%>78v.\+'
endfun
command! Wrap call Wrap()

fun! NoWrap()
	setlocal textwidth=0
	setlocal formatoptions-=at
	match none
endfun
command! NoWrap call NoWrap()

" default to email mode when we were spawned by the edit server
if $FROM_EDIT_SERVER == 'true'
	call FnEmailMode()
end

command! Emailmode call FnEmailMode()

command! -nargs=0 Spaces set et noet< | retab
fun! Tabsize(sz)
	let &l:shiftwidth=a:sz
	let &l:tabstop=a:sz
	let &l:softtabstop=a:sz
endfun
fun! GlobalTabsize(sz)
	let &shiftwidth=a:sz
	let &tabstop=a:sz
	let &softtabstop=a:sz
endfun
command! -nargs=1 Tabsize call Tabsize(<args>)

call GlobalTabsize(2)
" defaults for indent-finder when no other preference is clear from the file
let g:indent_finder_default_style="tab"
let g:indent_finder_default_width="2"

set cursorline
set ignorecase
set smartcase
set incsearch
set scrolloff=3
set sidescrolloff=5
set wildmode=longest,list
set autoindent
set cinkeys-=#
set mouse=a
" allow status-bar windows (0-height)
set wmh=0

" statusbar config:
set statusline=%< " truncation point
set statusline+=\  " leading space
set statusline+=%q " quickfix list
set statusline+=%-.80f\  " filename, left aligned @ 30chars
set statusline+=%#statuslinenc#
set statusline+=\ %m " modified flag
set statusline+=\ %#special#
set statusline+=%r " readonly flag
set statusline+=%#statuslinenc#
set statusline+=\ %l:%c
set statusline+=%=
set statusline+=▸%{&et?'space':'tab'}\ %{&sw} "indentation
set statusline+=\ \  " separator
set statusline+=%{&ff} "file format
set statusline+=• " separator
set statusline+=%{strlen(&fenc)?&fenc:'none'} "file encoding
set statusline+=\  "end with a space
set laststatus=2 " always show the status bar

" set iskeyword-=_ \" allow underscore to delimit words"


set tags+=.tags
let g:autotagTagsFile=".tags"
let g:EasyMotion_leader_key = '<Leader>m'
let g:EasyMotion_mapping_f = '<leader>f'
let g:EasyMotion_mapping_F = '<leader>F'
let g:EasyMotion_mapping_w = '<leader>w'
let g:EasyMotion_mapping_W = '<leader>W'
let g:EasyMotion_mapping_j = '<leader>j'
let g:EasyMotion_mapping_k = '<leader>k'
omap <silent> i_ <Plug>CamelCaseMotion_iw
xmap <silent> i_ <Plug>CamelCaseMotion_iw
omap <silent> i- <Plug>CamelCaseMotion_iw
xmap <silent> i- <Plug>CamelCaseMotion_iw
map <silent> _ <Plug>CamelCaseMotion_w
map <silent> <a--> <Plug>CamelCaseMotion_b

" (do it poorly in the terminal, because sometimes utf8 is broken)
fun! Lame_tabs()
	autocmd BufNewFile,BufRead * set list listchars=tab:>\ 
	set list listchars=tab:>\ 
endfun
command! LameTabs call Lame_tabs()

" draw tabs
autocmd BufNewFile,BufRead * set list listchars=tab:▸\ 
set list listchars=tab:▸\ 

"highlight any spaces that are followed by a tab (the horror!)
" and any _single_ space that comes after ^\t+ (this is usually accedental)
" and also trailing spaces
autocmd BufNewFile,BufRead * match Error /\(  \+\t\@=\)\|\(^\(\t\+\)\zs \ze[^ *]\)\|\([^ \t]\zs\s\+$\)/
                             match Error /\(  \+\t\@=\)\|\(^\(\t\+\)\zs \ze[^ *]\)\|\([^ \t]\zs\s\+$\)/

command! -narg=0 NixSyntax call vim_addon_nix#CheckSyntax()

" It's... syntastic!
let g:syntastic_check_on_wq = 0
let g:syntastic_mode_map = {
        \ "mode": "passive",
        \ "active_filetypes": ["python", "nix", "ocaml", "xml"],
        \ "passive_filetypes": [] }
let g:syntastic_python_checkers = [ "python" ] " shut up, pylint

fun! Save_if_possible()
	if len(expand("%")) > 0 && &buftype == ""
		noautocmd up
	else
		echo "[no file]"
	endif
endfun
autocmd FocusLost * nested call Save_if_possible()

augroup mkd
	autocmd BufRead *.mkd  set ai formatoptions=tcroqn2 comments=n:&gt spell mousemodel=popup textwidth=70;
augroup END


"" tab left & right
if has("mac")
	""NOTE: only run this on macvim - on gnome, it causes an ambiguous map for "<<" (unindent line)
	map <D-j> gt
	map <D-k> gT
else
	map <A-j> gt
	map <A-k> gT
end

" Visually select the text that was last edited/pasted
nmap gV `[V`]

" Bubble single lines
nmap <M-Down> ]e
nmap <M-S-J> ]e
nmap <M-Up> [e
nmap <M-S-K> [e
" Bubble selection
vmap <M-Down> ]e`[V`]
vmap <M-S-J> ]e`[V`]
vmap <M-Up> [e`[V`]
vmap <M-S-K> [e`[V`]

" use , for ;
nnoremap , ;
vnoremap , ;
nnoremap ; :
" visual mappings to highlight inside brackets ((like this) and this)
vmap ] i]
vmap [ i[
vmap ) i)
vmap ( i(
vmap ; ib
" indent & brace selection
vmap <leader>} >`<O<bs>{<esc>`>o<bs>}<esc>
nmap c] ci]
nmap c[ ci[
nmap c) ci)
nmap c( ci(
nmap c{ ci{
nmap c} ci}
nmap c; cib
" and keep going ...
" ctrl + b to highlight current word
map <Leader>b viw
" and then keep extending it
vmap <Leader>b o?\<<cr>o2/\><cr>h
" \w should maybe do the same thing?
" nmap <leader>w <c-b>
" vmap <leader>w <c-b>

xmap <Leader>s <Plug>Vsurround
" surround selection with things:
vmap <leader>( <esc>`>a)<esc>`<i(<esc>
vmap <leader>[ <esc>`>a]<esc>`<i[<esc>
"vmap <leader>< <esc>`>a><esc>`<i<<esc>
vmap <leader>{ <esc>`>a}<esc>`<i{<esc>
vmap <leader>' <esc>`>a'<esc>`<i'<esc>
vmap <leader>" <esc>`>a"<esc>`<i"<esc>
vmap <leader>` <esc>`>a`<esc>`<i`<esc>
nmap <leader>' vi'
nmap <leader>" vi"
nmap <leader>[ vi[
nmap <leader>` vi`

" ]] to go to next (/prev) quickfix item
nmap <A-]> :cn<cr>
nmap <A-[> :cp<cr>

" + expands a selection in both directions by one character
vmap + loho
vmap - holo

" + to increment a number (used to be c-a, but it hardly deserves such a prominent shortcut)
nnoremap + <c-a>

" ) kills the surrounding characters of a selection
vmap <leader>) <esc>`<hx`>x

" jump to alternate file
nmap <Leader>a :A<cr>
nmap <Leader>A :AS<cr>

" home & end
map <C-l> $
map <C-h> ^
" nul is ctrl-space for terminal
map <nul> ^
map <space> h
map <C-Space> ^
map <S-Space> b
" foward & back words at a time
map <S-h> b
map <S-l> w

" ctrl + backspace for deleting a word
imap <C-BS> <C-W>

" ctrl + space to insert an underscore
imap <C-space> _

" scroll (without moving cursor) on ctrl+j/k
nnoremap <C-k> <C-y>
nnoremap <C-j> <C-e>

vnoremap <C-k> <C-y>
vnoremap <C-j> <C-e>

" I want { and } to match whitespace-only lines, rather than just empty ones
" TODO: need to omit these from the search history
noremap { :silent ?^\s*$<cr>:silent nohl<cr>
noremap } :silent /^\s*$<cr>:silent nohl<cr>

vnoremap { ?^\s*$<cr>
vnoremap } /^\s*$<cr>

" copy / paste (gvim, with the gui clipboard)
vmap <C-c> "+y
inoremap <C-v> <C-r>+
cnoremap <C-v> <C-r>+
" c-v is still sometimes useful for literal <cr> chars, so use <c-l> (mnemonic 'literal')
cnoremap <C-l> <C-v>
inoremap <C-l> <C-v>

" shift-insert for pasting from the selection buffer
nmap <S-Ins> "*P
imap <S-Ins> <esc>"*pa
omap <S-Ins> <C-r>*
cmap <S-Ins> <c-r>*

" select all in visual mode
vmap <C-a> <esc>ggVG
nmap <C-a> ggVG

" delete to the "black hole" buffer
map <S-k> "_d

" new tab with <leader>T
nmap <leader>T :tabnew<cr>

nmap <leader>q :q<cr>
nmap <leader>Q :tabclose<cr>

" map alt+slash to line comment toggle
if has("mac")
	map <M-/> :TComment<cr>
else
	map <A-/> :TComment<cr>
end

" add Tcomment overrides
autocmd FileType nix set commentstring=#\ %s

" option (or alt) + r to run the current file
"nmap <D-r> :up<cr>:!%:p<cr>
nmap <A-r> :up<cr>:!%:p<cr>

" ctrl+s to save things!
nmap <C-s> :w<cr>
imap <C-s> <esc>:w<cr>a

" Q to (re) format things
vmap Q Jgqq
" Q to (re) format things
nmap Q gqq

nmap <leader>p V{jo}ko

let g:ctrlp_map=''
let g:ctrlp_working_path_mode=2 " current directory
"let g:ctrlp_user_command = ['.git/', 'cd %s && git ls-files --cached --other'] " include untracked files
let g:ctrlp_by_filename = 1
let g:ctrlp_switch_buffer = 2

" CommandT requires compilation, so we use CtrlP as a more portable fallback
command! -narg=0 FindMeSomeFiles exec(exists(":CommandT") == 2 ? "CommandT" : "CtrlP")
nmap <C-f> :FindMeSomeFiles<cr>

" use ag if available
if executable("ag")
	let g:ackprg = 'ag --nogroup --nocolor --column'
endif

" but always have ctrlp available as well
nmap <leader><C-f> :CtrlP<cr>
nmap <C-b> :CtrlPBuffer<cr>
" nmap <leader>b :FuzzyFinderBuffer<cr>
" nmap <leader>F :FuzzyFinderTaggedFile<cr>
nmap <leader>t :CtrlPTag<cr>

" leader-t for showing nerd-tree
nmap <leader>e :NERDTreeToggle<cr>
nmap <leader>E :NERDTreeFind<cr>

" find usages
nmap <a-F7> :Ack -wQ <c-r><c-w><cr>
vmap <M-F7> y:Ack -wQ "<C-R>""<cr>

" refresh / redraw
nmap <F5> :syntax sync fromstart<cr>:redraw!<cr>

" window management:
if has("mac")
	nmap <M-tab> <c-w>w
	nmap <M-C-tab> <c-w>W
else
	nmap <C-tab> <c-w>w
	nmap <S-C-tab> <c-w>W
endif
nmap <leader><c-l> <c-w>T

" copy full path to clipboard
nmap <C-c> :silent let @+ = expand("%:p")<cr>

nmap <A-o> :up<cr>:silent !gnome-open %:p<cr>
command! -narg=0 Open :silent :!gnome-open "`dirname "%:p"`" &
command! -narg=0 Term :silent :!gnome-terminal --working-directory="`dirname "%:p"`" &
command! -narg=0 CD :lcd %:p:h
command! -narg=0 Mdview :silent :!markdown "%" | htmlview &
command! -narg=0 Rstview :silent :!rst2html "%" | htmlview
augroup automake
augroup END
command! -narg=0 Automake autocmd automake BufWritePost <buffer> Make
command! -narg=0 AutomakeOff autocmd! automake

" silly shift-typos
command! -narg=0 Q :q
command! -narg=0 W :w
command! -narg=0 Wq :wq
command! -narg=0 WQ :wq

command! -narg=0 Xmlformat :%!XMLLINT_INDENT='	' xmllint --format -o - -
command! -narg=0 ClearMarkers :sign unplace *

" pyflakes shouldn't use quickfix; I use that for other stuff!
let g:pyflakes_use_quickfix = 0

" 0install tools helpers
command! -narg=0 Zeroreadme !cd %:p:h && 0readme %:t
command! -narg=0 Zerocopy !cd %:p:h && gnome-terminal -x /bin/bash -c "echo %:p; mkzero-gfxmonk -c %:t; bash"
command! -narg=0 Zerosign !cd %:p:h && gnome-terminal -x `which 0publish` --xmlsign %:p
command! Version !version

command! -narg=1 Boom put =system(\"boom echo <args>\")

if has("win32unix")
	" make `gf` work on windows paths
	set isfname+=:
	set isfname+=\\
	set includeexpr=substitute(system('cygpath\ '.shellescape(v:fname)),'\\n$','','')
end

fun! Snip(name)
	" get a snippet from the `snip` command line tool.
	let l:str = system("snip ". shellescape(a:name))
	return substitute(l:str, '\n\+$', '', 'g')
endfun

command! -narg=* Pos call cursor(<f-args>)
command! -narg=1 Column call cursor(line("."), <args>)

" trialling...
" hack to force autoload..
silent! call gsel#NO_SUCH_FUNCTION()
if exists("*gsel#DefaultMappings")
	let g:gsel_file_list_command = "bash -c 'if git rev-parse --show-toplevel >/dev/null 2>&1; then git ls-files .; else find . -type f; fi'"

	" ust a little bit roundabout... Assume if we have a systemd-user feed, we're
	" actually running the gsel server
	" XXX can we `test -f the existence of an abstract unix socket?
	if filereadable($HOME."/.config/zeroinstall-plugin-manager/http\%3A\%2F\%2Fgfxmonk.net\%2Fdist\%2F0install\%2Fsystemd-user.xml/uri-list")
		let g:gsel_command = "gsel-client"
	endif
	call gsel#DefaultMappings()
endif
